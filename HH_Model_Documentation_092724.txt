###### HH Model Documentation as of 09/27/24 ######

These are the most up to date params for the model as of 092724. Many changes were made following Kevin's input 
to get the cell to be more cell like by mainly changing the 12-16 difference down to ~5mV from closer to 12mV. He 
told us that the Hu2009 paper was probably not accurate. We changed the distribution of 12 and 16 in the AIS to be 
closer to 1/3 1.2 and 2/3 1.6.




shift5={"mut5":{"Rd": 0.023204006298533603, "Rg": 0.015604498120126004, "Rb": 0.0925081211054913, "Ra": 0.23933332265451177, "a0s": 0.0005226303768198727, "gms": 0.14418575154491814, "hmin": 0.008449935591049326, "mmin": 0.01193016441163175, "qinf": 5.7593653647578105, "q10": 2.1532859986639186, "qg": 1.2968193480468215, "qd": 0.661199851452832, "qa1": 4.492758160759386, "smax": 3.5557932199839737, "sh": 8.358558450280716, "thinf": -47.8194205612529, "thi2": -79.6556083820085, "thi1": -62.40165437813537, "tha": -33.850064879126805, "vvs": 1.4255479951467982, "vvh": -55.33213046147061, "vhalfs": -40.89976480829731, "zetas": 13.403615755952343}}


rbs_vshift = 13.5
changesna16 = {
        "sh": 8,
        "tha": -47+rbs_vshift,
        "qa": 7.2,
        "Ra": 0.4,
        "Rb": 0.124,
        "thi1": -61+rbs_vshift,
        "thi2": -61+rbs_vshift,
        "qd": 0.5,
        "qg": 1.5,
        "mmin": 0.02,  
        "hmin": 0.01,  
        "q10": 2,
        "Rg": 0.01,
        "Rd": 0.03,
        "thinf": -65+rbs_vshift,
        "qinf": 7,
        "vhalfs": -40+rbs_vshift,
        "a0s": 0.0003,
        "gms": 0.2,
        "zetas": 12,
        "smax": 10,
        "vvh": -58,
        "vvs": 2,
        "ar2": 1,
        #"ena": 55
        }


for fac in [1.2]:
    ###############################################################################################################################################################
    ##### ais12
    for i, factor in enumerate([1,0.9,0.8,0.7,0.6,0.5,0.4,0.3,0.2,0.1,0]):
      color = cmap(i/11)
    
      ## 1.2 factor
      sim12 = tf.Na12Model_TF(ais_nav12_fac=12*fac*factor,ais_nav16_fac=12*0.6,nav12=1*factor,nav16=1.3, somaK=1*2.2*0.01, KP=25*0.15, KT=5,#ais_nav12_fac=12*fac*factor,ais_nav16_fac=12*0.75
                                  ais_ca = 100*8.6*0.1,ais_Kca = 0.5,soma_na16=1*0.8,soma_na12=3.2*0.8,node_na = 1,
                                  na12name = 'na12annaTFHH',mut_name = 'na12annaTFHH',na12mechs = ['na12','na12mut'],
                                  na16name = 'na16HH_TF2',na16mut_name = 'na16HH_TF2',na16mechs=['na16','na16mut'],params_folder = './params/',
                                  plots_folder = f'{root_path_out}/{path}', update=True, fac=None)
      Vm12,_,t12,_ = sim12.get_stim_raw_data(stim_amp = 0.5,dt=0.005,rec_extra=False,stim_dur=500, sim_config = config) #stim_amp=0.5
      dvdt1 = np.gradient(Vm12)/0.005
      axs1.plot(Vm12[1:12000],dvdt1[1:12000],color=color, alpha=0.8,linewidth=1)
      
      NeuronModel.chandensities(name = f'{root_path_out}/{path}/densities_{factor}')
      sim12.plot_fi_curve_2line(wt_data=wt_fi,wt2_data=None,start=-0.4,end=1,nruns=140, fn=f'12-{factor}-FI',epochlabel='200ms')
      sim12.make_currentscape_plot(amp=0.5, time1=50,time2=100,stim_start=30, sweep_len=200,pfx=f'12-{factor}-')

      fig_volts,axs4 = plt.subplots(2,figsize=(cm_to_in(8),cm_to_in(15)))
      sim12.plot_stim(axs = axs4[0],stim_amp = 0.3,dt=0.005, clr=color)
      plot_dvdt_from_volts(sim12.volt_soma, sim12.dt, axs4[1],clr=color)
      fig_volts.savefig(f'{sim12.plot_folder}/12-{factor}-spikedvdt.pdf') #Change output file path here 









################################  AIS  ################################

      
	
	////////////////////////////////////////
	//New distribution from Kevin's guidance 092424//
	//"have 1.2 drop to 0 gBar by segment 3 instead of segment 5.  i know we're going for Hu Shu style where it looks like half half but the data support something more like 1/3rd 1.2
	//then take the 1.6 value at 6 and move that to position 3.  connect with a smooth line" - Kevin

	//WT 1.6
	gbar_na16(0:2*ais_end/10) = 0:ais_na16/3
	gbar_na16(2*ais_end/10:4*ais_end/10) = ais_na16/3:ais_na16/2
	gbar_na16(4*ais_end/10:8*ais_end/10) = ais_na16/2:ais_na16/2
	gbar_na16(8*ais_end/10:9*ais_end/10) = ais_na16/2:ais_na16/3
	gbar_na16(9*ais_end/10:ais_end) = ais_na16/3:naked_axon_na/2
	
	//Mut 1.6
	gbar_na16mut(0:2*ais_end/10) = 0:ais_na16/3
	gbar_na16mut(2*ais_end/10:4*ais_end/10) = ais_na16/3:ais_na16/2
	gbar_na16mut(4*ais_end/10:8*ais_end/10) = ais_na16/2:ais_na16/2
	gbar_na16mut(8*ais_end/10:9*ais_end/10) = ais_na16/2:ais_na16/3
	gbar_na16mut(9*ais_end/10:ais_end) = ais_na16/3:naked_axon_na/2

	gbar_na16(ais_end:1) = naked_axon_na/2:naked_axon_na/2 // 1/5th nav1.6
	gbar_na16mut(ais_end:1) = naked_axon_na/2:naked_axon_na/2 // 1/5th nav1.6


	//WT 1.2
	//gbar_na12(0:ais_end/10) = 0:ais_na12/3
	gbar_na12(0:ais_end/10) = ais_na12/8:ais_na12/2
	gbar_na12(ais_end/10:2*ais_end/10) = ais_na12/2:ais_na12/2
	gbar_na12(2*ais_end/10:3*ais_end/10) = ais_na12/2:ais_na12/2
	//gbar_na12(3*ais_end/10:4*ais_end/10) = ais_na12/2:ais_na12/6
	gbar_na12(3*ais_end/10:4*ais_end/10) = ais_na12/2:0
	gbar_na12(4*ais_end/10:ais_end) = 0:0 //##TF071624 changed to 0

	//Mut 1.2
	//gbar_na12mut(0:ais_end/10) = 0:ais_na12/3
	gbar_na12mut(0:ais_end/10) = ais_na12/8:ais_na12/2
	gbar_na12mut(ais_end/10:2*ais_end/10) = ais_na12/2:ais_na12/2
	gbar_na12mut(2*ais_end/10:3*ais_end/10) = ais_na12/2:ais_na12/2
	//gbar_na12mut(3*ais_end/10:4*ais_end/10) = ais_na12/2:ais_na12/6
	gbar_na12mut(3*ais_end/10:4*ais_end/10) = ais_na12/2:0
	gbar_na12mut(4*ais_end/10:ais_end) = 0:0 //##TF071624 changed to 0
	
	gbar_na12(ais_end:1) = 0:0 //naked axon ##Don't start naked axon until end of AIS
	gbar_na12mut(ais_end:1) = 0:0 //naked axon ##Don't start naked axon until end of AIS
	////////////////////////////////////////



################################  NeuronModelClass  ################################

        #___________________Kaustubh params
        h.dend_na12 = 2.48E-03 * dend_nav12
        
        # h.dend_na16 = 5.05E-03 * dend_nav16 ##TF020624
        h.dend_na16 = 0 ##TF020624
        h.dend_k = 0.0043685576 * dend_K
        

        ##062424 original params
        h.soma_na12 = 3.24E-02 * soma_nav12 
        h.soma_na16 = 7.88E-02 * soma_nav16
        
        ##TF062424 testing equal conductances
        # h.soma_na12 = 3.24E-02 * soma_nav12 
        # h.soma_na16 = 3.24E-02 * soma_nav16


        
      
        h.soma_K = 0.21330453 * soma_K
        
        # h.ais_na16 = 7.2696676 * ais_nav16
        h.ais_na16 = ais_nav16_fac * ais_nav16
        print(f'&&&&&&&&&&&&&&&&&&&&&&&&&&&&&##################### the ais factor is {ais_nav16_fac} ************************************************************')

        # h.ais_na12 = 1.03E+00 * ais_nav12
        h.ais_na12 = ais_nav12_fac * ais_nav12 #TF020124 added ais_nav12 factor to fine tune

        h.ais_ca = 0.0010125926 * ais_ca
        h.ais_KCa = 0.0009423347 * ais_KCa
        
        h.node_na = 0.9934221 * node_na
        print(f'The node_na is {h.node_na} &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&')

        h.axon_KP = 0.43260124 * axon_Kp
        h.axon_KT = 1.38801 * axon_Kt
        h.axon_K = 0.89699364 *2.1* axon_K
        h.axon_LVA = 0.00034828275 * axon_LVA
        h.axon_HVA = 1.05E-05 * axon_HVA
        h.axon_KCA = 0.4008224 * axon_Kca
        
        h.gpas_all = 1.34E-05 * gpas_all


        h.cm_all = 1.6171424

        
        
        #added gpas to see if i_pas changes on currentscape
        #h.gpas_all = .001

        

        h.dend_na12 = h.dend_na12 * nav12 * dend_nav12
        h.soma_na12 = h.soma_na12 * nav12 * soma_nav12
        
        # h.ais_na12 = h.ais_na12 * nav12 * ais_nav12
        if nav12 !=0:
            h.ais_na12 = (h.ais_na12 * ais_nav12)/nav12 ##TF020624 decouple ais Nav1.2 from overall nav12. Needed because update_mod_param called later multiplies by nav12
        else:
            h.ais_na12 = h.ais_na12 *ais_nav12
        
        # h.ais_na16 = h.ais_na16 * nav16 * ais_nav16
        if nav16 !=0:
            h.ais_na16 = (h.ais_na16 * ais_nav16)/nav16 ##TF020624 decouple ais Nav1.6 from overall nav16. Needed because update_mod_param called later multiplies by nav16
        else:
            h.ais_na12 = h.ais_na16 * ais_nav16

        h.dend_na16 = h.dend_na16 * nav16 * dend_nav16
        h.soma_na16 = h.soma_na16 * nav16 * soma_nav16



            def init_stim(self, sweep_len = 300, stim_start = 30, stim_dur = 200, amp = 0.3, dt = 0.1): ##TF071524 getting 1-3 APs for Roy
